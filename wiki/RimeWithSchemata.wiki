#summary Rime 輸入方案創作指南
#labels Phase-Support,Featured

= Rime with Schemata =

Rime 輸入方案創作《指南書》

※ 佛振 <chen.sst@gmail.com> 修訂於 2012年5月12日

= Rime 輸入方案 =

作者的一點主張：選用適合自己的輸入法。

來折騰 Rime 的同學，我只能說，您對輸入法的追求比較與衆不同啦！

當然，因爲您理想中的輸入方式千奇百怪、也許從沒有人那樣玩過，所以不可能在那種勾勾選選的介面上做得出來；需要親手來創作——

Rime 輸入方案 ！

== Rime 是啥 ==

Rime 不是一種輸入法。是從各種常見鍵盤輸入法中提煉出來的抽象的輸入算法框架。因爲 Rime 涵蓋了大多數輸入法的「共性」，所以在不同的設定下，Rime 可化爲不同的輸入法用來打字。

== Rime 輸入方案又是啥 ==

要讓 Rime 實現某種具體輸入法的功能，就需要一些數據來描述這種輸入法以何種形式工作。即，定義該輸入法的「個性」。

如「漢語拼音」、「注音」、「倉頡碼」、「五筆字型」，這些方法可憑藉 Rime 提供的通用設施、給定不同的工作參數來實作。以本文介紹的規格寫成一套套的配方，就是 Rime 輸入方案。

= 準備開工 =

Rime 是跨平臺的輸入法軟件，Rime 輸入方案可通用於以下發行版：
  * 【中州韻】 ibus-rime → Linux
  * 【小狼毫】 Weasel → Windows
  * 【鼠鬚管】 Squirrel → Mac OS X

取得適合你系統的最新版 Rime 輸入法，印一份《指南書》，準備開工了！

== Rime with Text Files ==

文本爲王。
Rime 的配置文件、輸入方案定義及詞典文件，均爲特定格式的文本文檔。
因此，一款夠專業的 *文本編輯器* ，是設計 Rime 輸入方案的必備工具。

Rime 中所有文本文檔，均要求以 UTF-8 編碼，並建議使用 UNIX 換行符（LF）。

鑑於一些文本編輯器會爲 UTF-8 編碼的文件添加 BOM 標記，爲防止誤將該字符混入文中，
莫要從文件的第一行開始正文，而請在該行行首以 # 記號起一行註釋，如：
{{{
# Rime default settings
}}}
{{{
# Rime schema: My First Cool Schema
}}}
{{{
# Rime dictionary: Lingua Latina
}}}
也可繼續以註釋行寫下方案簡介、碼表來源、製作者、修訂記錄等信息，再切入正文。

== 必知必會 ==

Rime 輸入法中，多用擴展名爲「.yaml」的文本文檔，這是以一種可讀性高的數據描述語言—— YAML 寫成。

請訪問 [http://yaml.org/] 瞭解 YAML 文檔格式。
下文只對部分語法作簡要說明，而將重點放在對語義的解讀上面。

Rime 輸入方案亦會用到「正則表達式」實現一些高級功能。

輸入方案設計者需要掌握這份文檔所描述的 Perl 正則表達式語法：

[http://www.boost.org/doc/libs/1_49_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html]

== Rime 中的數據文件分佈及作用 ==

除程序文件以外，Rime 還包括多種數據文件。
這些數據文件存在於以下位置：

共享資料夾
  * 【中州韻】  `/usr/share/ibus-rime/`
  * 【小狼毫】  `"安裝目錄\data"`
  * 【鼠鬚管】  `"/Library/Input Methods/Squirrel.app/Contents/SharedSupport/"`

用戶資料夾 
  * 【中州韻】  `~/.ibus/rime/`
  * 【小狼毫】  `"%APPDATA%\Rime"`
  * 【鼠鬚管】  `~/Library/Rime/`

共享資料夾包含預設輸入方案的源文件。
這些文件屬於 Rime 所發行軟件的一部份，在訪問權限控制較嚴格的系統上對用戶是只讀的，因此謝絕軟件版本更新以外的任何修改——
一旦用戶修改這裏的文件，很可能影響後續的軟件升級或在升級時丟失數據。

在「部署 Rime」操作時，將用到這裏的輸入方案源文件、並結合用戶定製的內容來編譯預設輸入方案。

用戶資料夾則包含爲用戶準備的內容，如：
  * 〔全局設定〕 `default.yaml`
  * 〔發行版設定〕 `weasel.yaml`
  * 〔預設輸入方案副本〕 `<方案標識>.schema.yaml`

  * ※〔安裝信息〕 `installation.yaml`
  * ※〔用戶狀態信息〕 `user.yaml`

編譯輸入方案所產出的二進制文件：
  * 〔Rime 棱鏡〕 `<方案標識>.prism.bin`
  * 〔Rime 固態詞典〕 `<詞典名>.table.bin`
  * 〔Rime 反查詞典〕 `<詞典名>.reverse.bin`

記錄用戶寫作習慣的文件：
  * ※〔用戶詞典〕 `<詞典名>.userdb.kct`
  * ※〔用戶詞典備份〕 `<詞典名>.userdb.kct.snapshot`

以及用戶自己設定的：
  * ※〔用戶對全局設定的定製信息〕 `default.custom.yaml`
  * ※〔用戶對預設輸入方案的定製信息〕 `<方案標識>.custom.yaml`
  * ※〔用戶自製輸入方案〕及配套的詞典源文件

註：以上標有 ※ 號的文件，包含用戶資料，您在清理文件時要注意備份！

= 詳解輸入方案 =

== 方案定義 ==

一套輸入方案，通常包含「方案定義」和「詞典」文件。

方案定義，命名爲 `<方案標識>.schema.yaml`，是一份包含輸入方案配置信息的 YAML 文檔。

文檔中需要有這樣一組方案描述：

{{{
# 以下代碼片段節選自 luna_pinyin.schema.yaml

schema:
  schema_id: luna_pinyin
  name: 朙月拼音
  version: "0.9"
  author:
    - 佛振 <chen.sst@gmail.com>
  description: |
    Rime 預設的拼音輸入方案。
}}}

首先來爲方案命名。`schema/name` 字段是顯示在〔方案選單〕中的名稱。

然後——重點是——要定一個在整個 Rime 輸入法中唯一的「方案標識」，即 `schema/schema_id` 字段的內容。
方案標識由小寫字母、數字、下劃線構成。
僅於輸入法內部使用，且會構成方案定義文件名的一部分，因此爲了兼容不同的文件系統，不要用大寫字母、漢字、空格和其他符號做方案標識。
一例：這款名爲【朙月拼音】的輸入方案，方案標識爲「luna_pinyin」。

方案如做升級，通過版本號（`schema/version`）來區分相互兼容的新舊版本。

版本號——以「.」分隔的整數（或文字）構成的字符串。

如下都是版本號常見的形式：
{{{
"1"      # 最好加引號表明是字符串！
"1.0"    # 最好加引號表明是字符串！
"0.9.8"
"0.9.8.custom.86427531"  # 這種形式是經過用戶自定義的版本；自動生成
}}}

然而，若對方案的升級會導致原有的用戶輸入習慣無法在新的方案中繼續使用，則需要換個新的方案標識。

比如【倉頡五代】之於【倉頡三代】、【五筆98】之於【五筆86】，其實已是互不兼容的輸入法。

`schema/author` ——列出作者和主要貢獻者，格式爲文字列表：

{{{
schema:
  author:
    - 作者甲 <alpha@rime.org>
    - 作者乙 <beta@rime.org>
    - 作者丙
}}}

`schema/description` ——對方案作簡要介紹的多行文字。

以上 `schema/schema_id`、`schema/version` 字段用於在程序中識別輸入方案，
而 `schema/name`、`schema/author`、`schema/description` 則主要是展示給用戶的信息。


除方案描述外，方案定義文件中還包含各種功能設定，控制着輸入法引擎的工作方式。


== 輸入法引擎與功能組件 ==

論 Rime 輸入法的工作流程：

  按鍵消息→後臺「服務」→分配給對應的「會話」→由「方案選單」或「輸入引擎」處理……

這裏要點是，有會話的概念：多窗口、多線操作嘛，你懂得的，同時與好幾位 MM 聊天時，有無有好幾組會話。
每一組會話中都有一部輸入引擎完成按鍵序列到文字的變換。

Rime 可以在不同會話裏使用不同輸入方案。因爲有「方案選單」。
方案選單本身可響應一些按鍵。但由於他不會寫字的緣故，更多時候要把按鍵遞給同一會話中的「輸入引擎」繼續處理。
方案選單的貢獻，就是給用戶一個便捷的方案切換介面，再把用戶挑中的輸入方案加載到輸入引擎。

再論輸入引擎的工作流程：

  加載輸入方案、預備功能組件；各就位之後就進入處理按鍵消息、處理按鍵消息……的循環。

響應各種按鍵、產生各類結果的工作，教不同的功能組件分擔了。

好，看代碼：

{{{
# luna_pinyin.schema.yaml
# ...

engine:                    # 輸入引擎設定，即掛接組件的「處方」
  processors:              # 一、這批組件處理各類按鍵消息
    - ascii_composer         
    - recognizer
    - key_binder
    - speller
    - punctuator
    - selector
    - navigator
    - express_editor
  segmentors:              # 二、這批組件識別不同內容類型，將輸入碼分段
    - ascii_segmentor
    - matcher
    - abc_segmentor
    - punct_segmentor
    - fallback_segmentor
  translators:             # 三、這批組件翻譯特定類型的編碼段爲一組候選文字
    - echo_translator
    - punct_translator
    - r10n_translator
    - reverse_lookup_translator
  filters:                 # 四、這批組件過濾翻譯的結果
    - simplifier
    - uniquifier
}}}

輸入引擎把完成具體功能的邏輯拆分爲可裝卸、組合的部件。
「加載」輸入方案，即按該處方掛接所需的功能組件、令這些組件從輸入方案定義中加載各自的設定、準備各司其職。
而他們接下來要完成的作業，先是由引擎收到的一份按鍵消息引發。

=== 理解 Processors ===

輸入引擎，作爲整體來看，以按鍵消息爲輸入，輸出包括三部分：
  * 一是對按鍵消息的處理結果：操作系統要一個結果、這按鍵、輪入法接是不接？
  * 二是暫存於輸入法、尚未完成處理的內容，會展現在輸入法候選窗中。
  * 三是要「上屏」的文字，並不是每按一鍵都有輸出。通常中文字都會伴隨「確認」動作而上屏，有些按鍵則會直接導致符號上屏，而這些還要視具體場景而定。

那麼第一類功能組件 `processor`s，就是比較籠統地、起着「處理」按鍵消息的作用。

按鍵消息依次送往列表中的 `processor`，由他給出對按鍵的處理意見：
  * 或曰「收」、即由 Rime 響應該按鍵；
  * 或曰「拒」、回禀操作系統 Rime 不做響應、請對按鍵做默認處理；
  * 或曰這個按鍵我不認得、請下一個 `processor` 繼續看。

優先級依照 `processors` 列表順序排定，接收按鍵者會針對按鍵消息做處理。

雖然看起來 `processor` 通過組合可以承擔引擎的全部任務，但爲了將邏輯繼續細分、Rime 又爲引擎設置了另外三類功能組件。這些組件都可以訪問引擎中的數據對象——輸入上下文，並將各自所做處理的階段成果存於其中。

`processor` 最常見的處理，便是將按鍵所產生的字符記入上下文中的「輸入碼」序列。
當「輸入碼」發生變更時，下一組組件 `segmentor`s 開始一輪新的作業。

=== 理解 Segmentors ===

Rime 可將文字、數字、符號等不同內容連續輸入，此時需要識別不同格式的輸入碼、將輸入碼分成若干段分而治之。
這通過數輪代碼段劃分操作完成。每一輪操作中、一衆 `segmentor`s 分別給出起始於某一處、符合特定格式的代碼段，識別到的最長代碼段成爲本輪劃分的結果，而給出這一劃分的一個或多個 `segmentor` 組件則可爲該代碼段打上「類型標籤」；從這一新代碼段的結束位置，開始下一輪劃分，直到整個輸入碼序列劃分完畢。

舉例來說，【朙月拼音】中，輸入碼 `2012nian\`，劃分爲三個編碼段：`2012`（貼`number`標籤）、`nian`（貼`abc`標籤）、`\`（貼`punct`標籤）。

那些標籤是初步劃分後判定的類型，也可能有一個編碼段貼多個標籤的情況。下一個階段中，`translator`s 會把特定類型的編碼段翻譯爲文字。

=== 理解 Translators ===

顧名思義，`translator` 完成由編碼到文字的翻譯。但有幾個要點：
  * 一是翻譯的對象是劃分好的一個代碼段。
  * 二是某個 `translator` 組件往往只翻譯具有特定標籤的代碼段。
  * 三是翻譯的結果可能有多條，每條結果成爲一個展現給用戶的候選項。
  * 四是代碼段可由幾種 `translator` 分別翻譯、翻譯結果按一定規則合併成一列候選。
  * 五是候選項所對應的編碼未必是整個代碼段。用拼音敲一個詞組時，詞組後面繼續列出單字候選，即是此例。

雙目如探針般進入內存查看，發現翻譯的結果呈現這種形式：
{{{
input | tag    | translations
------+--------+-------------------------------------
2012  | number | [ "2012" ], [ "二〇一二" ]
nian  | abc    | [ "年", "念", "唸",... ], [ "nian" ]
\     | punct  | [ "、", "\" ]
}}}

輸入串劃分爲多個代碼段、每段代碼又可具有多組翻譯結果；取各代碼段的首選結果連接起來，就是預備上屏的文字「2012年、」。

且將以上所示的數據稱爲「作文」。這是一篇未定稿（未搞定）的作文，輸入法介面此時顯示預備上屏的文字「2012年、」，並列出最末一個代碼段上的候選「、」及「\」以供選擇。

有兩款主力 `translator` 完成主要文字內容的翻譯，其實現的方式很不一樣：

  * `r10n_translator` 修煉羅馬字分析法，以「固定音節表」爲算法的基礎，識別輸入碼的音節構成，推敲排列組合、完成遣詞造句。
  * `table_translator` 修煉傳承自上世紀的碼表功夫，基於規則的動態碼表，構成編碼空間內一個開放的編碼集合。

拼音、注音、方言拼音，皆是以固定音節表上的拼寫排列組合的方式產生編碼，故適用羅馬字分析法。
倉頡、五筆字型這類則是傳統的碼表輸入法。

如果以碼表方式來寫拼音輸入方案，是怎樣的效果呢？雖然仍可完成輸入，但無法完全實現支持簡拼、模糊拼音、使用隔音符號的動態調頻、智能語句等有用的特性。

反之，以羅馬字方式使用碼表輸入法，則無法實現定長編碼頂字上屏、按編碼規則構詞等功能。在 Rime 各發行版預設輸入方案中，有一款「速成」輸入方案，即是以 `r10n_translator` 翻譯倉頡碼，實現全、簡碼混合的語句輸入。

概括起來，這是兩種構造新編碼的方式：羅馬字式輸入方案以一組固定的基本音節碼創造新的組合而構詞，而碼表式輸入方案則以一定碼長爲限創造新的編碼映射而構詞。

=== 理解 Filters ===

上一步已經收集到各個代碼段的翻譯結果，當輸入法需要在介面呈現一頁候選項時，就從最末一個代碼段的結果集中挑選、直至取夠方案中設定的頁最大候選數。

每從結果集選出一條字詞、會經過一組 `filter`s 過濾。多個 `filter` 串行工作，最終產出的結果進入候選序列。

`filter` 可以：
  * 改裝正在處理的候選項，修改某些屬性值：簡化字、火星文、菊花文有無有？過時了！有 Rime，你對文字的想象力終於得救
  * 消除當前候選項，比如檢測到重複（由不同 `translator` 產生）的候選條目
  * 插入新的候選項，比如根據已有條目插入關聯的結果
  * 修改已有的候選序列


== 碼表與詞典 ==

詞典是 `translator` 的參考書。

他往往與同名輸入方案配套使用，如拼音的詞典以拼音碼查字，倉頡的詞典以倉頡碼查字。但也可以由若干編碼屬於同一系統的輸入方案共用，如各種雙拼方案，都使用和拼音同樣的詞典，於是不僅復用了碼表數據，也可共享用戶以任一款此系列方案錄入的自造詞（仍以碼表中的形式即全拼編碼記錄）。

Rime 的詞典文件，命名爲 `<詞典名>.dict.yaml`，包含一份碼表及對應的規則說明。
詞典文件的前半部份爲一份 YAML 文檔：

{{{
# 注意這裏以 --- ... 分別標記出 YAML 文檔的起始與結束位置
# 在 ... 標記之後的部份就不會作 YAML 文檔來解讀

---
name: luna_pinyin
version: "0.9"
sort: by_weight
use_preset_vocabulary: true
...
}}}

解釋：

  * `name`: 詞典名，內部使用，命名原則同「方案標識」；可以與配套的輸入方案標識一致，也可不同；
  * `version`: 管理詞典的版本，規則同輸入方案定義文件的版本號；
  * `sort`: 詞條排序方式，可選填 `by_weight`（按詞頻高低排序）或 `original`（保持原碼表中的順序）；
  * `use_preset_vocabulary`: 填 `true` 或 `false`，選擇是否導入預設詞彙表【八股文】。


碼表，定義了輸入法中編碼與文字的對應關係。

碼表位於詞典文件中 YAML 結束標記之後的部份。
其格式爲以製表符分隔的字段（TSV），每行定義一條「文字－編碼」的對應關係：
{{{
# 單字
你	ni
我	wo
的	de	99%
的	di	1%
地	de	10%
地	di	90%
目	mu
好	hao

# 詞組
你我
你的
我的
我的天
天地	tian di
好天
好好地
目的	mu di
目的地	mu di di
}}}
※注意： *不要* 從網頁複製以上代碼到實作的詞典文件！因爲網頁裏製表符被轉換成空格從而不符合 Rime 詞典要求的格式。

碼表部份，除了以上格式的編碼行，還可以包含空行（不含任何字符）及註釋行（行首爲 # 符號）。

以製表符（Tab）分隔的第一個字段是所定義的文字，可以是單字或詞組；

第二個字段是與文字對應的編碼；若該編碼由多個「音節」組成，音節之間以空個分開；

可選地、第三個字段是設定該字詞權重的頻度值（非負整數），或相對於預設權值的百分比（浮點數%）。
在拼音輸入法中，往往多音字的若干種讀音使用的場合不同，於是指定不同百分比來修正每個讀音的使用頻度。

詞組如果滿足以下條件，則可以省去編碼字段：

  * 詞組中每個單字均有編碼定義
  * 詞組中不包含多音字（例：你我），或多音字在該詞組中讀音的權值超過該多音字全部讀音權值的5%（例：我的）

這種條件下，詞組的編碼可由單字編碼的組合推導出來。

反之，則有必要給出詞組的編碼以消除自動註音的不確定性（例：天地）。

當含有多音字的詞組缺少編碼字段時，自動註音程序會利用權重百分比高於5%的讀音進行組合、生成全部可能的註音，如：

  「好好地」在編譯時自動註音爲「`hao hao de`」、「`hao hao di`」


== 八股文 ==

Rime 有一份名爲【八股文】的預設詞彙表。

多數輸入方案需要用到一些標準白話文中的通用詞彙。爲免重複在每份碼表中包含這些詞彙，減少輸入方案維護成本，Rime 提供了一份預設詞彙表及自動編碼（註音）的設施。

創作輸入方案時，如果希望完全控制詞彙表的內容而不採用【八股文】中的詞組，只須直接將詞彙編入碼表即可。

否則，在詞典文件中設定 `use_preset_vocabulary: true` 將【八股文】導入該詞典；
在碼表中給出單字碼、需要分辨多音字的詞組編碼、以及該輸入方案特有的詞彙，其他交給自動註音來做就好啦。

Rime預設輸入方案正是利用這份詞彙表及自動註音工具，在不犧牲效果及可維護性的前提下、使詞典文件壓縮到最小的行數。

【八股文】包含從 CC-CEDICT、新酷音等開源項目中整理出來的約二十三萬條詞彙，其用字及詞頻數據針對傳統漢字做過調整。因此基於這份詞彙表產生的輸入結果，比較接近以傳統漢字行文的實際用法。

爲了充分利用【八股文】提供的詞彙，自定義的詞典應保證單字碼表收錄了符合 opencc 字形標準的常用字。特別注意，該標準對以下幾組異體字的取捨，【八股文】將這些字（包括詞組及字頻）統一到左邊一列的字形。
{{{
爲	為
僞	偽
嬀	媯
潙	溈
兇	凶
啓	啟
棱	稜
污	汙
泄	洩
涌	湧
牀	床
着	著
竈	灶
羣	群
衆	眾
裏	裡
踊	踴
覈	核
}}}

部署過程中，未能完成自動註音的字、詞會以警告形式出現在日誌文件裏。如果所報告的字爲生僻字、您可以忽略他；如果警告中大量出現某個常用字，那麼應該注意到碼表裏缺失了該字的註音。


== 編譯輸入方案 ==

將寫好的輸入方案佈署到 Rime 輸入法的過程，稱爲「編譯」：

爲查詢效率故，輸入法工作時不直接加載文本格式的詞典源文件，而要在編譯過程中，爲輸入方案生成專爲高速查詢設計的「.bin」文件。

編譯時程序做以下幾件事：

  * 將用戶的定製內容合併到輸入方案定義中，在用戶資料夾生成 .schema.yaml 文檔副本；
  * 依照輸入方案中指定的詞典：求得音節表（不同種編碼的集合）、單字表；
  * 對詞典中未提供編碼的詞組自動註音，也包括從【八股文】導入的詞組；
  * 建立按音節編碼檢索詞條的索引，製作 Rime 固態詞典；
  * 建立按詞條檢索編碼的索引，製作 Rime 反查詞典；
  * 依照音節表和方案定義中指定的拼寫運算規則，製作 Rime 棱鏡。


== 佈署 Rime ==

初次安裝 Rime 輸入法，無有任何輸入方案和用戶設定。因此安裝的最後一個步驟即是把發行版預設的輸入方案和設定文件佈署到 Rime 爲該用戶創建的工作目錄，至此 Rime 纔成爲一部可以發動的輸入引擎。

此後無論是修改已有方案的設定，或是添加了新的輸入方案，都需要「重新佈署 Rime」成功後方可使用戶的新設定作用於 Rime 輸入法。

〔★〕重新佈署 Rime 的方法是：

  * 【小狼毫】在托盤圖標上右鍵選擇「重新佈署」；
  * 【鼠鬚管】在系統語言文字選單中選擇「重新佈署」；
  * 【中州韻】暫時只好這樣做：刪除用戶資料夾的 `default.yaml` 之後、執行 `ibus-daemon -drx` 重載IBus


= 定製指南 =

Rime 輸入方案，將 Rime 輸入法的設定整理成完善的、可分發的形式。
但並非一定要創作新的輸入方案，才可以改變 Rime 的行爲。

當用戶需要對 Rime 中的各種設定做小幅的調節，最直接、但不完全正確的做法是：編輯用戶資料夾中那些 .yaml 文檔。

這一方法有弊端：

  * 當 Rime 軟件升級時，也會升級各種設定檔、預設輸入方案。用戶編輯過的文檔會被覆寫爲更高版本，所做調整也便丟失了。
  * 即使在軟件升級後再手動恢復經過編輯的文件，也會因設定檔的其他部分未得到更新而失去本次升級新增和修復的功能。


因此，對於隨 Rime 發行的設定檔及預設輸入方案，推薦的定製方法是：

創建一個文件名的主體部份（「.」之前）與要定製的文件相同、次級擴展名（位於「.yaml」之前）寫作 `.custom` 的定製檔，形如：

{{{
patch:
  "一級設定項/二級設定項/三級設定項": 新的設定值
  "另一個設定項": 新的設定值
  "再一個設定項": 新的設定值
}}}

`patch` 定義了一組「補靪」，以源文件中的設定爲底本，寫入新的設定項、或以新的設定值取代舊有的值。

以下這些例子，另載於一篇《定製指南》，其中所介紹的知識和技巧，對於創作新的輸入方案也有使處。


=== 一例、定製每頁候選數 ===

[CustomizationGuide#%E4%B8%80%E4%BE%8B%E3%80%81%E5%AE%9A%E8%A3%BD%E6%AF%8F%E9%A0%81%E5%80%99%E9%81%B8%E6%95%B8 詳解]

=== 一例、定製標點符號 ===

[CustomizationGuide#%E4%B8%80%E4%BE%8B%E3%80%81%E5%AE%9A%E8%A3%BD%E6%A8%99%E9%BB%9E%E7%AC%A6%E8%99%9F 詳解]

=== 一例、定製簡化字輸出 ===

[CustomizationGuide#%E4%B8%80%E4%BE%8B%E3%80%81%E5%AE%9A%E8%A3%BD%E7%B0%A1%E5%8C%96%E5%AD%97%E8%BC%B8%E5%87%BA 詳解]

=== 一例、定製方案選單 ===

重要！創作了新的輸入方案，最後一步就是在「方案選單」裏啓用他。

[CustomizationGuide#%E4%B8%80%E4%BE%8B%E3%80%81%E5%AE%9A%E8%A3%BD%E6%96%B9%E6%A1%88%E9%81%B8%E5%96%AE 詳解]

=== 一例、定製喚出方案選單的快捷鍵 ===

[CustomizationGuide#%E4%B8%80%E4%BE%8B%E3%80%81%E5%AE%9A%E8%A3%BD%E5%96%9A%E5%87%BA%E6%96%B9%E6%A1%88%E9%81%B8%E5%96%AE%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%8D%B5 詳解]

=== 一例、定製【小狼毫】字體字號 ===

[CustomizationGuide#%E4%B8%80%E4%BE%8B%E3%80%81%E5%AE%9A%E8%A3%BD%E3%80%90%E5%B0%8F%E7%8B%BC%E6%AF%AB%E3%80%91%E5%AD%97%E9%AB%94%E5%AD%97%E8%99%9F 詳解]

=== 一例、定製【小狼毫】配色方案 ===

[CustomizationGuide#%E4%B8%80%E4%BE%8B%E3%80%81%E5%AE%9A%E8%A3%BD%E3%80%90%E5%B0%8F%E7%8B%BC%E6%AF%AB%E3%80%91%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88 詳解]


= 拼寫運算 =

應該算是 Rime 輸入法最主要的獨創技術。

概括來說就是將方案中的編碼通過規則映射到一組全新的拼寫形式！
也就是說能讓 Rime 輸入方案在不修改碼表的情況下、適應不同的輸入習慣。

拼寫運算能用來：
  * 改革拼寫法
    * 將編碼映射到基於同一音系的其他拼寫法，如注音、拼音、國語羅馬字相互轉換
    * 重定義注音鍵盤、雙拼方案
  * 實現簡拼查詢
  * 在音節表上靈活地定義模糊音規則
  * 實現音節自動糾錯
  * 變換回顯的輸入碼或提示碼，如將輸入碼顯示爲字根、注音符號、帶聲調標註的羅馬字

給力嗎？

[SpellingAlgebra ★這裏] 有介紹拼寫運算的專題文章。


= 綜合演練 =

== 破空中出鞘 ==

如果你安裝好了Rime卻不會玩，就一步一步跟我學吧。

本教程每個步驟的完整代碼可由此取得：

http://code.google.com/p/rimeime/source/browse/trunk/doc/tutorial/

=== Hello, Rime! ===

第一個例子，總是最簡單的（也是最傻的）。

{{{
# Rime schema
# encoding: utf-8
#
# 最簡單的 Rime 輸入方案
#

schema:
  schema_id: hello    # 注意此ID與文件名裏 .schema.yaml 之前的部分相同
  name: 大家好        # 將在〔方案選單〕中顯示
  version: "1"        # 這是文字類型而非整數或小數，如 "1.2.3"
}}}

起首幾行是註釋。而後只有一組必要的方案描述信息。

這一課主要練習建立格式正確的YAML文檔。

  * 要點一，讓你的文本編輯器以UTF-8編碼保存該文件；
  * 要點二，注意將 `schema:` 之下的三行代碼以空格縮進——我的習慣是用兩個空格——而 *不要* 用Tab字符來縮進。

縮進表示設定項所屬的層次。在他處引用到此文檔中的設定項，可分別以 `schema/schema_id`, `schema/name`, `schema/version` 來指稱。

我現在把寫好的方案文檔命名爲 `hello.schema.yaml`，丟進用戶資料夾——對，只要這一個文件就妥了；

然後，啓用他。有些版本會有「方案選單設定」這個介面，在那裏勾選【大家好】這個方案即可。若無有設定介面，則按照上文《定製方案選單》一節來做。

好運！我已建立了一款名爲【大家好】的新方案！雖然他沒有實現任何效果、按鍵仍會像無有輸入法一樣直接輸出西文。

=== 開始改裝 ===

爲了處理字符按鍵、生成輸入碼，本例向輸入引擎添加兩個功能組件。

以下代碼仍是ID爲 `hello` 的新款輸入方案，但增加了 `schema/version` 的數值。
以後每個版本，都以前一個版本爲基礎改寫，略去無有改動的部分，以突出重點。

{{{
# ... 
schema:
  schema_id: hello
  name: 大家好
  version: "2"

engine:
  processors:
    - fluency_editor
  segmentors:
    - fallback_segmentor
}}}

`fluency_editor` 將字符按鍵記入輸入上下文，`fallback_segmentor` 將輸入碼連綴成一段。於是重新佈署後，按下字符鍵不再直接上屏，而顯示爲輸入碼。

你會發現，該輸入法只是收集了鍵盤上的可打印字符，並於按下空格、回車鍵時令輸入碼上屏。

現在就好似寫輸入法程序的過程中，將將取得一小點成果，還有很多邏輯未實現。不同的是，在Rime輸入方案裏寫一行代碼，頂 Rime 開發者所寫的上百上千行。因此我可以很快地組合各種邏輯組件、搭建出心裏想的輸入法。

=== 爲編碼創建候選項 ===

第二版的【大家好】將鍵盤上所有字符都記入輸入碼，這對整句輸入有用，但是時下流行輸入法只處理編碼字符、其他字符直接上屏的形式。爲了對編碼字符做出區分，以下改用 `speller` + `express_editor` 的組合取代 `fluency_editor`：

{{{
# ...

schema:
  # ...
  version: "3"

engine:
  processors:
    - speller          # 把字母追加到編碼串
    - express_editor   # 空格確認當前輸入、其他字符直接上屏
  segmentors:
    - fallback_segmentor
}}}

`speller` 默認只接受小寫拉丁字母作爲輸入碼。
試試看，輸入其他字符如大寫字母、數字、標點，都會直接上屏。並且如果已經輸入了編碼時，下一個直接上屏的字符會將輸入碼頂上屏。

再接着，創建一個最簡單的候選項——把編碼串本身作爲一個選項。故而會提供這個選項的新組件名叫 `echo_translator`。

{{{
# ...

engine:
  # ...
  translators:
    - echo_translator  # （無有其他結果時，）創建一個與編碼串一個模樣的候選項
}}}

至此，【大家好】看上去與一個真正的輸入法形似啦。只是還不會打出「大家好」哇？

=== 編寫詞典 ===

那就寫一部詞典，碼表中設定以 `hello` 作爲短語「大家好」的編碼：

{{{
# Rime dictionary
# encoding: utf-8

---
name: hello
version: "1"
sort: original
...

大家好	hello
再見	bye
再會	bye
}}}
※注意： *不要* 從網頁複製以上代碼到實作的詞典文件！因爲網頁裏製表符被轉換成空格從而不符合 Rime 詞典要求的格式。


同時修改方案定義：

{{{
#...

schema:
  # ...
  version: "4"

engine:
  #...
  segmentors:
    - abc_segmentor       # 標記輸入碼的類型
    - fallback_segmentor
  translators:
    - echo_translator
    - table_translator    # 碼表式轉換

translator:
  dictionary: hello       # 設定 table_translator 使用的詞典名
}}}

工作流程是這樣的：

  * `speller` 將字母鍵加入輸入碼序列
  * `abc_segmentor` 給輸入碼打上標籤 `abc`
  * `table_translator` 把帶有 `abc` 籤的輸入碼以查表的方式譯爲中文
  * `table_translator` 所查的碼表在 `translator/dictionary` 所指定的詞典裏

現在可以敲 `hello` 而打出「大家好」。完工！

=== 實現選字及換頁 ===

等一下。

記得 `hello` 詞典裏，還有個編碼叫做 `bye`。敲 `bye`，Rime 給出「再見」、「再會」兩個候選短語。

這時敲空格鍵，就會打出「再見」；那麼怎樣打出「再會」呢？

TODO:

== 修煉之道 ==

TODO: 從〇開始全程打造一款經典輸入方案

== 最高武藝 ==

學了拼寫運算，來設計一款【智能ABC雙拼】輸入方案做練習吧！

{{{
# Rime schema
# encoding: utf-8

schema:
  schema_id: double_pinyin_abc  # 專有的方案標識
  name: 智能ABC雙拼
  version: "0.9"
  author:
    - 佛振 <chen.sst@gmail.com>
  description: |
    朙月拼音，兼容智能ABC雙拼方案。

switches:
  - name: ascii_mode
    reset: 0
    states: [ 中文, 西文 ]
  - name: full_shape
    states: [ 半角, 全角 ]
  - name: simplification
    states: [ 漢字, 汉字 ]

engine:
  processors:
    - ascii_composer
    - recognizer
    - key_binder
    - speller
    - punctuator
    - selector
    - navigator
    - express_editor
  segmentors:
    - ascii_segmentor
    - matcher
    - abc_segmentor
    - punct_segmentor
    - fallback_segmentor
  translators:
    - echo_translator
    - punct_translator
    - r10n_translator
    - reverse_lookup_translator
  filters:
    - simplifier
    - uniquifier

speller:
  alphabet: zyxwvutsrqponmlkjihgfedcba  # 呃，倒背字母表完全是個人喜好
  delimiter: " '"  # 隔音符號用「'」；第一位的空白用來自動插入到音節邊界處
  algebra:  # 拼寫運算規則，這個纔是實現雙拼方案的重點。寫法有很多種，當然也可以把四百多個音節碼一條一條地列舉
    - erase/^xx$/             # 碼表中有幾個拼音不明的字，編碼成xx了，消滅他
    - derive/^([jqxy])u$/$1v/
    - xform/^zh/A/            # 替換聲母鍵，用大寫以防與原有的字母混淆
    - xform/^ch/E/
    - xform/^sh/V/
    - xform/^([aoe].*)$/O$1/  # 添上固定的零聲母o，先標記爲大寫O
    - xform/ei$/Q/            # 替換韻母鍵
    - xform/ian$/W/           # ※2
    - xform/er$|iu$/R/        # 對應兩種韻母的；音節er現在變爲OR了
    - xform/[iu]ang$/T/       # ※1
    - xform/ing$/Y/
    - xform/uo$/O/
    - xform/uan$/P/           # ※3
    - xform/i?ong$/S/
    - xform/[iu]a$/D/
    - xform/en$/F/
    - xform/eng$/G/
    - xform/ang$/H/           # 檢查一下在此之前是否已轉換過了帶介音的ang；好，※1處有了
    - xform/an$/J/            # 如果※2、※3還無有出現在上文中，應該把他們提到本行之前
    - xform/iao$/Z/           # 對——像這樣讓iao提前出場
    - xform/ao$/K/
    - xform/in$|uai$/C/       # 讓uai提前出場
    - xform/ai$/L/
    - xform/ie$/X/
    - xform/ou$/B/
    - xform/un$/N/
    - xform/[uv]e$|ui$/M/
    - xlit/QWERTYOPASDFGHJKLZXCVBNM/qwertyopasdfghjklzxcvbnm/  # 最後把雙拼碼全部變小寫

translator:
  dictionary: luna_pinyin     # 與【朙月拼音】共用詞典
  prism: double_pinyin_abc    # prism 要以本輸入方案的名稱來命名，以免把朙月拼音的拼寫映射表覆蓋掉
  preedit_format:             # 這段代碼用來將輸入的雙拼碼反轉爲全拼顯示；待見雙拼碼的可以把這段拿掉
    - xform/o(\w)/0$1/        # 零聲母先改爲0，以方便後面的轉換
    - xform/(\w)q/$1ei/       # 雙拼第二碼轉換爲韻母
    - xform/(\w)n/$1un/       # 提前轉換雙拼碼 n 和 g，因爲轉換後的拼音裏就快要出現這兩個字母了，那時將難以分辨出雙拼碼
    - xform/(\w)g/$1eng/      # 當然也可以採取事先將雙拼碼變爲大寫的辦法來與轉換過的拼音做區分，可誰讓我是高手呢
    - xform/(\w)w/$1ian/
    - xform/([dtnljqx])r/$1iu/  # 對應多種韻母的雙拼碼，按搭配的聲母做區分（最好別用排除式如 [^o]r 容易出狀況）
    - xform/0r/0er/             # 另一種情況，注意先不消除0，以防後面把e當作聲母轉換爲ch
    - xform/([nljqx])t/$1iang/
    - xform/(\w)t/$1uang/       # 上一行已經把對應到 iang 的雙拼碼 t 消滅，於是這裏不用再列舉相配的聲母
    - xform/(\w)y/$1ing/
    - xform/([dtnlgkhaevrzcs])o/$1uo/
    - xform/(\w)p/$1uan/
    - xform/([jqx])s/$1iong/
    - xform/(\w)s/$1ong/
    - xform/([gkhaevrzcs])d/$1ua/
    - xform/(\w)d/$1ia/
    - xform/(\w)f/$1en/
    - xform/(\w)h/$1ang/
    - xform/(\w)j/$1an/
    - xform/(\w)k/$1ao/       # 默默檢查：雙拼碼 o 已經轉換過了
    - xform/(\w)l/$1ai/
    - xform/(\w)z/$1iao/
    - xform/(\w)x/$1ie/
    - xform/(\w)b/$1ou/
    - xform/([nl])m/$1ve/
    - xform/([jqxy])m/$1ue/
    - xform/(\w)m/$1ui/
    - "xform/(^|[ '])a/$1zh/"  # 復原聲母，音節開始處的雙拼字母a改寫爲zh；其他位置的才真正是a
    - "xform/(^|[ '])e/$1ch/"
    - "xform/(^|[ '])v/$1sh/"
    - xform/0(\w)/$1/          # 好了，現在可以把零聲母拿掉啦
    - xform/([nljqxy])v/$1ü/   # 這樣纔是漢語拼音 :-)

reverse_lookup:
  dictionary: cangjie5
  prefix: "`"
  tips: 〔倉頡〕
  preedit_format:
    - "xlit|abcdefghijklmnopqrstuvwxyz|日月金木水火土竹戈十大中一弓人心手口尸廿山女田難卜符|"
  comment_format:
    - xform/([nl])v/$1ü/

punctuator:
  import_preset: default

key_binder:
  import_preset: default

recognizer:
  import_preset: default
  patterns:
    reverse_lookup: "`[a-z]*$"
}}}

完畢。
這是一道大題。通過改造拼寫法而創作出新的輸入方案。

== 關於調試 ==

如此複雜的輸入方案，很可能需要反覆調試方可達到想要的結果。

請於試驗時及時查看日誌中是否包含錯誤信息（在以下文件中搜索「Error」以及「Warning」）：

  * `<用戶資料夾>/rime.log` 含使用當中產生的日誌，如果新方案的輸出與設計不一致，原因可能在此
  * `<用戶資料夾>/deployer.log` 含部署時產生的日誌，如果不知爲何、新作品不可用，答案可能在此

沒有任何錯誤信息，就是不好使，有可能是碼表本身的問題，比如把碼表中文字和編碼兩列弄顛倒了——Rime 等你輸入由漢字組成的編碼，然而鍵盤沒有可能做到這一點（否則也不再需要輸入法了）。

後續有計劃爲輸入方案創作者開發名爲「拼寫運算調試器」的工具，能夠較直觀地看到每一步拼寫運算的結果。有助於定義雙拼這樣大量使用拼寫運算的方案。


= 東風破 =

「東風破早梅，向暖一枝開。」

構想在 Rime 輸入軟件完善後、能夠連結漢字字形、音韻、輸入法愛好者的共同興趣，形成穩定的使用者社羣，搭建一個分享知識的平臺。

而【東風破】，定義爲 Rime 輸入方案倉庫，則是分享 Rime 輸入方案的平臺。

Rime 是一款強調個性的輸入法。

Rime 不要定義輸入法應當是哪個樣、而要定義輸入法可以玩出哪些花樣。

Rime 不可能通過預設更多的輸入方案來滿足玩家的需求；真正的玩家一定有一般人想不到的高招。

未來一定會有，【東風破】，讓用家輕鬆地找到最新、最酷、最適合自己的 Rime 輸入方案。